Example 1:
```
fn main() {
    let mut s = String::from("hello");
    let ref1 = &s;
    let ref2 = &ref1;
    let ref3 = &ref2;
    s = String::from("goodbye");
    println!("{}", ref3.to_uppercase());
}
```
`s` is already borrowed by `ref1` and then `ref2` and then `ref3`. The ownership has already been transferred to ref3. So the change of s is not permitted because the s is already a pointer points to a moved memory.



Example 2:
```
fn drip_drop() -> &String {
    let s = String::from("hello world!");
    return &s;
}
```
&s returns a reference to data owned by the current function. Should return a data owned by outsider?
so just return a String type instead a reference to ensures the ownership is safely transmitted without freed as leaving the function zone.


Example 3:
```
fn main() {
    let s1 = String::from("hello");
    let mut v = Vec::new();
    v.push(s1);
    let s2: String = v[0].clone();
    println!("{}", s2);
}
```
move occurs because value has type `String`, which does not implement the `Copy` trait
Should copy a new one.